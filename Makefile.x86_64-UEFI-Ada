NAME:=HAVK
TARGET:=x86_64-UEFI-Ada

BUILD_DIR:=./build/$(TARGET)/
SRC_DIR:=./src/$(TARGET)/
$(shell mkdir -p $(BUILD_DIR))

# A normal x86-64 targeting GCC seems to be able to compile
# EFI applications, so I do not think a cross-compiler is necessary.
# Clang is also capable. You need both C and Ada enabled for GCC.
CC=x86_64-pc-linux-gnu-gcc
LD=ld
AS=nasm

OVMF_DIR=./src/ovmf-x64/
LIB_DIR=/usr/lib/

EFI_DIR=/usr/include/efi/
EFI_CRT0=$(SRC_DIR)crt0-efi-x86_64.o
EFI_LINK=$(SRC_DIR)elf_x86_64_efi.lds

EFI_C_STD=-std=c11
EFI_C_WARN=-Wall
EFI_C_OPT=-nostdlib -fpic -fno-stack-protector -fno-strict-aliasing -fno-builtin \
	  -fshort-wchar -mno-red-zone
EFI_C_INC=-I $(EFI_DIR) -I $(EFI_DIR)x86_64 -I $(EFI_DIR)protocol
EFI_C_LIB=-l efi -l gnuefi
EFI_C_DEF=-D EFI_FUNCTION_WRAPPER
EFI_C_FLAGS=$(EFI_C_STD) $(EFI_C_WARN) $(EFI_C_OPT) $(EFI_C_INC) $(EFI_C_LIB) $(EFI_C_DEF)

EFI_LD_OPT=-nostdlib -Bsymbolic -shared -no-undefined -znocombreloc
EFI_LD_INC=-L $(LIB_DIR) -T $(EFI_LINK)
EFI_LD_LIB=-l efi -l gnuefi
EFI_LD_FLAGS=$(EFI_LD_OPT) $(EFI_LD_INC) $(EFI_CRT0)

# The source and object paths must be named to what the GNAT tools look for.
ADA_RTS_DIR:=$(BUILD_DIR)ada_rts/
ADA_SOURCE_PATH:=$(ADA_RTS_DIR)adainclude/
ADA_OBJECT_PATH:=$(ADA_RTS_DIR)adalib/

HAVK_ADA_STD=-gnat2012 -gnatyN -gnatec=$(SRC_DIR)gnat.adc -masm=intel
HAVK_ADA_OPT=-c -O0 -g3 -ggdb -fno-stack-protector -nostdlib
HAVK_ADA_INC=--RTS=$(ADA_RTS_DIR) -I $(SRC_DIR)include
HAVK_ADA_FLAGS=$(HAVK_ADA_STD) $(HAVK_ADA_OPT) $(HAVK_ADA_INC)

QEMU_FLAGS:=-monitor stdio -s -d guest_errors -m 1024
LOOP_DEVICE=/dev/loop3

EFI_NAME:=bootx64
EFI_C_FILE:=$(SRC_DIR)$(EFI_NAME).c
EFI_OBJ_FILE:=$(BUILD_DIR)$(EFI_NAME).o
EFI_SHRD_OBJ_FILE:=$(BUILD_DIR)$(EFI_NAME).so

ADA_MAIN_FILE=havk.ali
ADA_BODY_FILE=$(SRC_DIR)havk/%.adb
ADA_SPEC_FILE=$(SRC_DIR)havk/%.ads
ADA_OBJ_FILE=$(BUILD_DIR)%.o

ADA_BODY_FILES=$(wildcard $(SRC_DIR)havk/*.adb)
ADA_SPEC_FILES=$(wildcard $(SRC_DIR)havk/*.ads)
HAVK_ADA_BODY_FILES=$(patsubst $(ADA_BODY_FILE),$(ADA_OBJ_FILE),$(ADA_BODY_FILES))
HAVK_ADA_SPEC_FILES=$(patsubst $(ADA_SPEC_FILE),$(ADA_OBJ_FILE),$(ADA_SPEC_FILES))

EFI_FILE:=$(BUILD_DIR)$(NAME).efi
ELF_FILE:=$(BUILD_DIR)$(NAME).elf
IMAGE_FILE:=$(BUILD_DIR)$(NAME).img

.DEFAULT_GOAL: all
.PHONY: all
all: $(ELF_FILE)

# TODO: This should probably be split up or even just made into a shell script.
$(ADA_RTS_DIR):
	mkdir -p $(ADA_RTS_DIR)
	mkdir -p $(ADA_OBJECT_PATH)
	mkdir -p $(ADA_SOURCE_PATH)
	cp -r $(SRC_DIR)adainclude/* $(ADA_SOURCE_PATH)

	cd $(ADA_OBJECT_PATH) &&\
	gnatmake -a -gnatec=../../../../$(SRC_DIR)gnat.adc --RTS=../../ada_rts/ \
	../adainclude/* --GCC="$(CC)" -cargs -nostdlib -ansi -pedantic -O0 -g

	$(CC)-ar rc $(ADA_OBJECT_PATH)libgnat.a $(ADA_OBJECT_PATH)*.o

$(BUILD_DIR)boot.o: $(SRC_DIR)boot.asm
	$(AS) -f elf64 -F dwarf $< -o $@

$(ADA_OBJ_FILE): $(ADA_BODY_FILE) $(ADA_RTS_DIR)
	$(CC) $(HAVK_ADA_FLAGS) $< -o $@

# TODO: Clean up the binding and linking commands by making their arguments
# into makefile variables.
$(ELF_FILE): $(BUILD_DIR)boot.o $(HAVK_ADA_BODY_FILES)
	gnatbind -static -nostdinc -nostdlib \
	--RTS=$(ADA_RTS_DIR) $(BUILD_DIR)$(ADA_MAIN_FILE)

	gnatlink -Wl,--gc-sections -static -nostartfiles --RTS=$(ADA_RTS_DIR) \
	-nodefaultlibs -T $(SRC_DIR)linker.ld $(BUILD_DIR)$(ADA_MAIN_FILE) \
	--LINK="$(CC)" -o $@

$(EFI_OBJ_FILE): $(EFI_C_FILE)
	$(CC) $(EFI_C_FLAGS) -c $< -o $@

$(EFI_SHRD_OBJ_FILE): $(EFI_OBJ_FILE)
	$(LD) $(EFI_LD_FLAGS) $< -o $@ $(EFI_LD_LIB)

$(EFI_FILE): $(EFI_SHRD_OBJ_FILE)
	objcopy -j .text -j .sdata -j .data -j .dynamic -j .dynsym \
	-j .rel -j .rela -j .reloc  -j .debug_info -j .debug_abbrev \
	-j .debug_loc -j .debug_aranges -j .debug_line -j .debug_macinfo \
	-j .debug_str --target=efi-app-x86_64 $< $@.dbg

	objcopy -j .text -j .sdata -j .data -j .dynamic -j .dynsym \
	-j .rel -j .rela -j .reloc --target=efi-app-x86_64 $< $@

$(IMAGE_FILE): $(EFI_FILE) $(ELF_FILE)
	dd if=/dev/zero of=$@ bs=1k count=1500

	parted $@ --align opt --script \
	mktable gpt \
	mkpart primary fat32 5% 95% \
	name 1 EFI \
	set 1 esp on

	losetup -P $(LOOP_DEVICE) $@
	mkfs.vfat $(LOOP_DEVICE)p1
	mkdir -p $(BUILD_DIR)mount
	mount $(LOOP_DEVICE)p1 $(BUILD_DIR)mount

	mkdir -p $(BUILD_DIR)mount/EFI/BOOT
	cp $< $(BUILD_DIR)mount/EFI/BOOT/BOOTX64.EFI
	mkdir -p $(BUILD_DIR)mount/HAVK
	cp $(ELF_FILE) $(BUILD_DIR)mount/HAVK/

	umount $(BUILD_DIR)mount
	losetup -d $(LOOP_DEVICE)

.PHONY: qemu-efi
qemu-efi: $(IMAGE_FILE)
	qemu-system-x86_64 \
	-drive if=pflash,format=raw,unit=0,\
	file=$(OVMF_DIR)OVMF_CODE-pure-efi.fd,readonly=on \
	-drive if=pflash,format=raw,unit=1,\
	file=$(OVMF_DIR)OVMF_VARS-pure-efi.fd,readonly=off \
	-cpu qemu64 -net none -hda $< $(QEMU_FLAGS)
