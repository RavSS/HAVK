###############################################################################
## Program         -- The HAVK Operating System                              ##
## Filename        -- tasking.S                                              ##
## License         -- GNU General Public License version 3.0                 ##
## Original Author -- Ravjot Singh Samra, Copyright 2019-2020                ##
###############################################################################

# This structure must match the Ada "callee-saved register" record.
.STRUCT 0 # RSP is specially treated (i.e. not here).
	RBX_STATE:
.STRUCT RBX_STATE + 8
	RBP_STATE:
.STRUCT RBP_STATE + 8
	R12_STATE:
.STRUCT R12_STATE + 8
	R13_STATE:
.STRUCT R13_STATE + 8
	R14_STATE:
.STRUCT R14_STATE + 8
	R15_STATE:
.STRUCT R15_STATE + 8
	# In long mode, SS is basically always the same as the other segment
	# selector registers. I'll treat FS and GS specially later on.
	SS_STATE:
.STRUCT SS_STATE + 8

.MACRO SAVE_REGISTERS_TO_STATE REGISTER_WITH_STATE_POINTER:req
	MOV [\REGISTER_WITH_STATE_POINTER + RBX_STATE], RBX
	MOV [\REGISTER_WITH_STATE_POINTER + RBP_STATE], RBP
	MOV [\REGISTER_WITH_STATE_POINTER + R12_STATE], R12
	MOV [\REGISTER_WITH_STATE_POINTER + R13_STATE], R13
	MOV [\REGISTER_WITH_STATE_POINTER + R14_STATE], R14
	MOV [\REGISTER_WITH_STATE_POINTER + R15_STATE], R15
	# Don't bother saving segment register states. Assign SS
	# statically at task creation based on the DPL.
.ENDM

.MACRO LOAD_REGISTERS_FROM_STATE REGISTER_WITH_STATE_POINTER:req
	MOV RBX, [\REGISTER_WITH_STATE_POINTER + RBX_STATE]
	MOV RBP, [\REGISTER_WITH_STATE_POINTER + RBP_STATE]
	MOV R12, [\REGISTER_WITH_STATE_POINTER + R12_STATE]
	MOV R13, [\REGISTER_WITH_STATE_POINTER + R13_STATE]
	MOV R14, [\REGISTER_WITH_STATE_POINTER + R14_STATE]
	MOV R15, [\REGISTER_WITH_STATE_POINTER + R15_STATE]
	MOV DS, [\REGISTER_WITH_STATE_POINTER + SS_STATE]
	MOV ES, [\REGISTER_WITH_STATE_POINTER + SS_STATE]
	MOV FS, [\REGISTER_WITH_STATE_POINTER + SS_STATE]
	MOV GS, [\REGISTER_WITH_STATE_POINTER + SS_STATE]
	# CS and SS are already handled.
.ENDM

.SECTION .bss

# This is a temporary stack for calling the Ada functions to perform task
# management inside the task switching routine because I am not bothered
# to do it all in assembly. Avoids needing to hardcode array calculations etc.
# Each context switch should use the top and clobber anything from the previous
# context switch that remains. Increase it if needed. Check the ".su" files
# that are generated by GCC in the build directory.
.ALIGN 16
.GLOBAL __task_management_stack_end
.GLOBAL __task_management_stack_base
__task_management_stack_end:
	.SPACE 4096
__task_management_stack_base:

.SECTION .text

.GLOBAL assembly__prepare_task_stack
# (RDI => index of the pre-modified CS descriptor for whichever ring,
#  RSI => index of the pre-modified DS descriptor for whichever ring,
#  RDX => initial instruction pointer for the new task,
#  RCX => the top of the new task's stack)
assembly__prepare_task_stack:
	CLI # Disable interrupts (hopefully again) just to be sure.
	XCHG RCX, RSP # Switch to the task's stack.

	PUSH RSI # Push the DS.
	PUSH RSP # Push the task's stack.

	# Push a custom FLAGS value in the size of RFLAGS.
	PUSH 0x206 # Bit 1 (always set), even parity, interrupts enabled.

	PUSH RDI # Push the CS.
	PUSH RDX # The initial RIP value.

	XCHG RCX, RSP # Switch back to the original stack.
	MOV RAX, RCX # Return the subtracted RSP value in RAX.
	RET

# Reminder that this is an ISR. It is not a simple procedure/function.
# It can be called from another interrupt handler via interrupt nesting.
.GLOBAL assembly__switch_task
# (RDI => active task's register state)
assembly__switch_task:
	SAVE_REGISTERS_TO_STATE RDI # Save and continue to clobber if required.

	MOV RDI, RSP # Get ready to pass the task stack in RDI.
	LEA RSP, [RIP + __task_management_stack_base] # Load the special stack.

	# Takes in an argument in RDI indicating the active task's stack and
	# then changes the active task index, as a store happens in a switch.
	CALL ada__store_task

	# We are now ready to get the new task's register state.
	CALL ada__get_task_state # The state record pointer is in RAX.
	LOAD_REGISTERS_FROM_STATE RAX # Load them and don't touch them.

	CALL ada__get_task_stack # Get the next task's stack in RAX.
	MOV RSP, RAX # Now we've switched to the next task's stack.

	# Since this can either be called in IRQ 0 or independently at
	# interrupt vector 100, reset the master PIC to cover the former case.
	MOV AL, 0x20 # RAX does not need to be restored.
	OUT 0x20, AL
	REX.W IRET # We're now at the next task.

.GLOBAL assembly__start_tasking
# ()
assembly__start_tasking:
	CLI # Disable any interrupts just in case as usual.
	LOCK INC BYTE PTR [ada__tasking_enabled] # Enable tasking.

	LEA RSP, [RIP + __task_management_stack_base] # Load the special stack.

	CALL ada__get_task_state # The state record pointer is in RAX.
	LOAD_REGISTERS_FROM_STATE RAX

	CALL ada__get_task_stack # Get the active task's stack.
	MOV RSP, RAX # Switch to it.

	REX.W IRET # We have finally entered multi-tasking mode.
