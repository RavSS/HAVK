###############################################################################
## Program         -- The HAVK Operating System                              ##
## Filename        -- tasking.S                                              ##
## License         -- GNU General Public License version 3.0                 ##
## Original Author -- Ravjot Singh Samra, Copyright 2019-2020                ##
###############################################################################

# TODO: These are obviously incomplete and lack the SIMD registers.
# Resolve it later when it matters. No attempt to check the stack limits
# is made either, which should probably be crucial to add later. The registers
# below are all of the callee-saved ones for the System V AMD64 ABI. There
# is no need to save the stack since we save it to a task control block.
.MACRO SAVE_REGISTERS_TO_STACK # Requires 48 available bytes on the stack.
	PUSH RBX
	PUSH RBP
	PUSH R12
	PUSH R13
	PUSH R14
	PUSH R15
.ENDM
.MACRO LOAD_REGISTERS_FROM_STACK # Takes 48 bytes off the stack.
	POP R15
	POP R14
	POP R13
	POP R12
	POP RBP
	POP RBX
.ENDM

# Add a bunch of (to be) zeroed registers. I'm not sure what initial
# values they should have, but this seems to work.
# TODO: Maybe cram a return address to a function that indicates the
# new task has finished.
.MACRO SAVE_DEFAULT_REGISTERS_TO_STACK ZEROED_REGISTER:req
	# There's no `PUSH imm64`. A blank register must be used for speed if
	# we are to assume that the memory is not already zeroed out. Be safe.
	XOR \ZEROED_REGISTER, \ZEROED_REGISTER # Empty values for now.
	PUSH \ZEROED_REGISTER # RBX
	PUSH \ZEROED_REGISTER # RBP
	PUSH \ZEROED_REGISTER # R12
	PUSH \ZEROED_REGISTER # R13
	PUSH \ZEROED_REGISTER # R14
	PUSH \ZEROED_REGISTER # R15
.ENDM

.SECTION .bss

# This is a temporary stack for calling the Ada functions to perform task
# management inside the task switching routine because I am not bothered
# to do it all in assembly. Avoids needing to hardcode array calculations etc.
# Each context switch should use the top and clobber anything from the previous
# context switch that remains. Increase it if needed. Check the ".su" files
# that are generated by GCC in the build directory.
.ALIGN 16
.GLOBAL __task_management_stack_end
.GLOBAL __task_management_stack_base
__task_management_stack_end:
	.SPACE 4096
__task_management_stack_base:

.SECTION .text

.GLOBAL assembly__prepare_task
# (RDI => index of the pre-modified CS descriptor for whichever ring,
#  RSI => index of the pre-modified DS descriptor for whichever ring,
#  RDX => initial instruction pointer for the new task,
#  RCX => the top of the new task's stack)
assembly__prepare_task:
	CLI # Disable interrupts (hopefully again) just to be sure.
	XCHG RCX, RSP # Switch to the task's stack.

	PUSH RSI # Push the DS.
	PUSH RSP # Push the task's stack.

	# Push a custom FLAGS value in the size of RFLAGS.
	PUSH 0x206 # Bit 1 (always set), even parity, interrupts enabled.

	PUSH RDI # Push the CS.
	PUSH RDX # The initial RIP value.

	SAVE_DEFAULT_REGISTERS_TO_STACK RAX # Use RAX as the null register.

	XCHG RCX, RSP # Switch back to the original stack.
	MOV RAX, RCX # Return the subtracted RSP value in RAX.

	RET

.GLOBAL assembly__switch_task
# ()
assembly__switch_task:
	# Begin state save.
	SAVE_REGISTERS_TO_STACK
	# Begin stack switch.

	MOV RDI, RSP # Get ready to pass the task stack in RDI.
	LEA RSP, [RIP + __task_management_stack_base] # Load the special stack.
	PUSH RDI # Pass it as the "Task_Stack" argument.

	# Store the stack indicated in RDI and change the active task.
	CALL ada__store_task
	POP RDI # Clean up the arguments just in case.

	# Get the next task's stack in RAX.
	CALL ada__get_task
	MOV RSP, RAX
	# Now we've switched to the next task's stack and can load registers.

	# End stack switch.
	LOAD_REGISTERS_FROM_STACK
	# End state load.

	# Since this can either be called in IRQ0 or independently at interrupt
	# vector 100, reset the master PIC to cover the former case.
	MOV AL, 0x20 # RAX does not need to be restored.
	OUT 0x20, AL
	REX.W IRET # We're now at the next task.

.GLOBAL assembly__start_tasking
# ()
assembly__start_tasking:
	CLI # Disable any interrupts just in case as usual.
	MOV BYTE PTR [ada__tasking_enabled], 1 # Enable tasking.

	LEA RSP, [RIP + __task_management_stack_base] # Load the special stack.
	CALL ada__get_task # Get the active task's stack.
	MOV RSP, RAX # Switch to it.

	LOAD_REGISTERS_FROM_STACK # Loads the default registers we pushed.

	REX.W IRET # We have finally entered multi-tasking mode.
