###############################################################################
## Program         -- HAVK                                                   ##
## Filename        -- tasking.S                                              ##
## License         -- GNU General Public License version 3.0                 ##
## Original Author -- Ravjot Singh Samra, Copyright 2019-2020                ##
###############################################################################

# This structure must match the Ada "callee_saved_register" record.
.STRUCT 0 # RSP is specially treated (i.e. not here).
	RBX_STATE:
.STRUCT RBX_STATE + 8
	RBP_STATE:
.STRUCT RBP_STATE + 8
	R12_STATE:
.STRUCT R12_STATE + 8
	R13_STATE:
.STRUCT R13_STATE + 8
	R14_STATE:
.STRUCT R14_STATE + 8
	R15_STATE:
.STRUCT R15_STATE + 8
	# In long mode, SS is basically always the same as the other segment
	# selector registers. I'll treat FS and GS specially later on.
	SS_STATE:
.STRUCT SS_STATE + 8

.MACRO SAVE_REGISTERS_TO_STATE REGISTER_WITH_STATE_POINTER:req
	MOV [\REGISTER_WITH_STATE_POINTER + RBX_STATE], RBX
	MOV [\REGISTER_WITH_STATE_POINTER + RBP_STATE], RBP
	MOV [\REGISTER_WITH_STATE_POINTER + R12_STATE], R12
	MOV [\REGISTER_WITH_STATE_POINTER + R13_STATE], R13
	MOV [\REGISTER_WITH_STATE_POINTER + R14_STATE], R14
	MOV [\REGISTER_WITH_STATE_POINTER + R15_STATE], R15
	# Don't bother saving segment register states. Assign SS
	# statically at task creation based on the DPL.
.ENDM

.MACRO LOAD_REGISTERS_FROM_STATE REGISTER_WITH_STATE_POINTER:req
	MOV RBX, [\REGISTER_WITH_STATE_POINTER + RBX_STATE]
	MOV RBP, [\REGISTER_WITH_STATE_POINTER + RBP_STATE]
	MOV R12, [\REGISTER_WITH_STATE_POINTER + R12_STATE]
	MOV R13, [\REGISTER_WITH_STATE_POINTER + R13_STATE]
	MOV R14, [\REGISTER_WITH_STATE_POINTER + R14_STATE]
	MOV R15, [\REGISTER_WITH_STATE_POINTER + R15_STATE]
	MOV DS, [\REGISTER_WITH_STATE_POINTER + SS_STATE]
	MOV ES, [\REGISTER_WITH_STATE_POINTER + SS_STATE]
	MOV FS, [\REGISTER_WITH_STATE_POINTER + SS_STATE]
	MOV GS, [\REGISTER_WITH_STATE_POINTER + SS_STATE]
	# CS and SS are already handled.
.ENDM

.SECTION .isolated_bss

# This is a temporary stack for calling the Ada functions to perform task
# management inside the task switching routine because I am not bothered
# to do it all in assembly. Avoids needing to hardcode array calculations etc.
# Each context switch should use the top and clobber anything from the previous
# context switch that remains. Increase it if needed. Check the ".su" files
# that are generated by GCC in the build directory. This is in the isolated BSS
# as the stack may be referenced outside of the kernel's page layout.
.ALIGN 16
.GLOBAL var__task_management_stack_base
var__task_management_stack_end:
	.SPACE 4096
var__task_management_stack_base:

# We need to check if the interruption came from kernel-land or user-land, so
# we can return with the appropriate CR3 contents. We will store it here as the
# full 64-bit length instead of using a potentially clobbered register. Only
# need to compare the first 16 bits (word length).
.ALIGN 4
var__interrupted_dpl_value:
	.QUAD 0

.SECTION .isolated_text

# This is a reused sequence when switching to a task and when starting tasking.
# It first loads the stack's original callee-saved registers, changes the page
# layout, and then it switches to the task's stack. It expects the temporary
# task management stack to be loaded, and then switches to the actual task's
# virtual stack only after switching the virtual memory layout.
.MACRO RETRIEVE_RSP_AND_CR3
	# We are now ready to get the new task's register state.
	CALL ada__get_task_state # The state record pointer is in RAX.
	LOAD_REGISTERS_FROM_STATE RAX # Load them and don't touch them.

	CALL ada__get_task_stack # Get the next task's stack in RAX.
	PUSH RAX # Need to save it to the stack so we don't clobber it later.

	# Since we're currently in ring 0, we will have the correct DS index
	# for a comparison. We don't switch if the stack we get our privilege
	# changes from is also already a kernel stack.
	MOV RDI, SS # Check if we need to swap to the task's CR3 below.
	CMP DI, WORD PTR [RIP + var__interrupted_dpl_value] # Compare the SSs.
	JE 1f # If we have the same DPL, then we still need the kernel CR3.

	CALL assembly__switch_to_task_cr3 # Set the CR3 register right now.

	1:
		# This increments the old RSP value and then RSP gets an all
		# new value.
		POP RSP # Now we've switched to the next task's stack.
.ENDM

.GLOBAL assembly__start_tasking
# ()
assembly__start_tasking:
	CLI # Disable any interrupts just in case as usual.
	LOCK INC BYTE PTR [var__tasking_enabled] # Enable tasking.

	LEA RSP, [RIP + var__task_management_stack_base] # Load the stack.

	# Zero it out, just in case, as it's in the ".isolated_bss" section
	# which may not be properly zeroed.
	MOV QWORD PTR [RIP + var__interrupted_dpl_value], 0

	RETRIEVE_RSP_AND_CR3

	REX.W IRET # We have finally entered multi-tasking mode.

# Reminder that this is an ISR. It is not a simple procedure/function.
# It can be called from another interrupt handler via interrupt nesting.
.GLOBAL assembly__switch_task
# ()
assembly__switch_task:
	# The SS value of the interrupted state is on the stack (32 bytes after
	# RSP) and it is a 64-bit zero-extended 16-bit value.
	MOV RAX, QWORD PTR [RSP + 32] # Get the interrupted SS value.
	MOV QWORD PTR [RIP + var__interrupted_dpl_value], RAX # Now store it.

	CALL assembly__switch_to_kernel_cr3 # Only touches RAX and RSP.

	CALL ada__get_task_state # Active task state structure address in RAX.
	SAVE_REGISTERS_TO_STATE RAX # Save and continue to clobber if required.

	MOV RDI, RSP # Get ready to pass the task stack in RDI.
	LEA RSP, [RIP + var__task_management_stack_base] # Load our stack.

	# Takes in an argument in RDI indicating the active task's stack and
	# then changes the active task index, as a store happens in a switch.
	CALL ada__store_task

	RETRIEVE_RSP_AND_CR3

	# Since this can either be called in another IRQ or independently at
	# interrupt vector 100, we need to signal end-of-interrupt.

	# Reset the LAPIC (hopefully in x2APIC mode).
	XOR RAX, RAX # Just need to write zero to the register.
	XOR RDX, RDX
	MOV RCX, 0x80B # The EOI MSR index.
	WRMSR

	REX.W IRET # We're now at the next task.

.GLOBAL assembly__switch_to_kernel_cr3
# ()
assembly__switch_to_kernel_cr3:
	MOV RAX, QWORD PTR [RIP + var__kernel_page_map_base_address]
	MOV CR3, RAX
	RET

.GLOBAL assembly__switch_to_task_cr3
# ()
assembly__switch_to_task_cr3:
	MOV AL, BYTE PTR [RIP + var__tasking_enabled]
	CMP AL, 0 # If it's not enabled, then we don't do the CR3 switch.
	JZ 1f

	CALL ada__get_task_cr3 # Get the CR3 value and load it.
	MOV CR3, RAX

	1:
		RET
